# 闭包学习

> 闭包在我们学习 JS 中也是非常重要的概念之一，很多开发者都对它“了如指掌”。可是闭包绝不是一个单一的概念，其中涵盖了：作用域、作用域链、执行上下文、内存管理等多个知识点，接下来就让我们一块来学习一下闭包的知识点吧。

# 作用域

> 作用域可以被理解为某种规则下的限定范围，该规则用于指导开发者如何在特定的场景下查找变量。

> 在 JS 中，ES6 出来之前，一般来说只有函数作用域和全局作用域之分。

## 函数作用域

> 在函数体内定义的变量，被函数消费。

```js
function foo() {
  var a = 'bar';
  console.log(a);
}
foo(); // bar
console.log(a); // 报错a is not defined未定义变量
```

## 全局作用域

> 在 js 文件的全局中定义的变量。

```js
var b = 'bar';
function foo() {
  // 函数体内找不到变量b就会往外层去寻找：就近原则
  console.log(b);
}
foo(); // bar
```

## 变量提升

我们在使用`var`变量的时候，存在一个变量提升的概念

```js
function foo() {
  console.log(a); // undefined
  var a = 1;
}
```

这个时候我们看到输出的是一个`undefined`并不是未定义，那么我们看一下具体是怎么实现的呢？

```js
function foo() {
  var a;
  console.log(a);
  a = 1;
}
```

> 上边就是变量被提升后生成的一种代码结构

如果我们使用`let`和`const`就不会被提升到前面，并会抛出一个未定义的异常信息。

## 暂时性死区

正是因为存在了`let`和`const`且不存在变量提升的问题，那么在使用的时候，一定要避免这种暂时性死区。

```js
function foo() {
  console.log(bar);
  let bar = 3;
}
```

这段代码在定义`bar`之前打印了`bar`这样就会存在一个暂时性死区，如果在死区内访问变量会直接报错未定义。

## 代码执行的阶段

### 代码的预编译阶段

1. 在预编译阶段对变量进行声明;
2. 在预编译阶段对变量进行提升，但值是`undefined`;
3. 在预编译阶段对所有非表达式的函数声明进行提升。

> 代码的执行过程就像一条流水线，第一道工序就是在预编译阶段创建变量对象，此时仅仅是创建并未进行相应的赋值操作，下一道工序就是代码执行阶段，变量对象会转为激活对象。

## 调用栈

一个函数调用了另一个函数，另一个函数又调用了另外一个函数，这就是调用栈。

```js
function foo1() {
  foo2();
}

function foo2() {
  foo3();
}

function foo3() {
  foo4();
}

function foo4() {
  console.log('foo4');
}

foo1();
```

入栈顺序：foo1 -> foo2 -> foo3 -> foo4

出栈顺序：foo4 -> foo3 -> foo2 -> foo1

<Alert type="info">
函数在执行完毕出栈的时候，函数内的局部变量在下一个垃圾回收节点会被回收，该函数对应的执行上下文将会被销毁，这也是我们在外界无法访问函数内定义的变量的原因。
</Alert>

## 闭包

前面的知识，是对于我们学习闭包的一种铺垫性的概念，我们现在开始真正的学习一下什么是闭包。

首先最直白的定义就是：函数嵌套函数时，内层的函数引用了外层函数作用域下的变量，并且内层函数在全局环境下可访问，这就形成了一个闭包。

例子：

```js
function numGenerator() {
  let num = 1;
  num++;
  return () => {
    console.log(num);
  };
}

var getNum = numGenerator();
getNum(); // 2
```

根据上边的例子，我们发现内部的函数被在全局中调用了，也就是说`numGenerator`出栈了但是其变量`num`依然会存在，仍然有机会被外界访问。

那么，我们使用闭包的好处是什么呢？

1. 使用闭包实现模块化
2. 例如在 Redux 源码的中间件中大量运用了闭包（函数式理念）

### 内存管理

我们知道内存空间可以被分为，堆空间和栈空间

栈空间：有操作系统自动分配释放，存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。

堆空间：一般由开发者分配释放，关于这部分空间要考虑垃圾回收的问题。

_在 JS 中的数据类型：_

基本类型：`undefined、null、number、string、boolean`等

引用类型：`object、array、function`等

一般情况下，基本数据类型按照值大小保存在栈空间中，占有固定的大小，引用类型保存在堆空间中，内存大小并不固定，需按引用情况来进行访问。
